
# OOP 2 - Prototypical Inheritance
___
#### Table of Contents
* [intro](#welcome-to-inheritance)
* [Absolute Must Learn Fundamentals](#prototypical-fundamentals)
    * [proto lookup chain](#proto-lookup-chain)
    * [Useful Native Methods](#useful-native-methods)
    * [Recommended Practices](#recommended-practices)
* [Using Inheritance Fundamentals](#using-inheritance-fundamentals)    
    * [factories](#factories)
    * [factories and closures](#factories-and-closures)
    * [recommeded design patterns](#recomended-design-patterns)
* [Other Ways to Inherit](#other-ways-to-inherit)
    * [Constructor Functions](#constructor-functions)
    * [Classes with Constructor Functions](#classes-with-constructor-functions)
    * [ES6 classes](#es6-classes)
* [Op Eds](#comprehensive-resources)
___
___
# Welcome to Inheritance
Inheritance in programming languages is very similar to inheritance in the people world.  If one object inherits from another, that means it behaves an aweful lot like it's 'ancestor' without being identical. JS's approach to inheritance is called '_Protoypical Inheritance_'.

Even if you didn't know it you've been taking advantage of inheritance since day 1.  Arrays are a great example:
```javascript
var array = [0, 1];
var deletedElement = array.splice(0, 1);
console.log(array, deletedElement);
```
Where did '.splice' come from?  You certainly didn't write it.  What happens if you do this:
```javascript
array.splice = function(arg) { console.log(arg) };
array.splice(0, 1);
```
And when you look up the [documentation for '.splice'](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) what's all this about 'Array.prototype.splice()'?

The short answer is that 'Array.prototype' is the ancestor of all arrays. All objects have a properyt called '\_\_proto\_\_' that sets that object's ancestor. Because the '\_\_proto\_\_' of all arrays is 'Array.prototype', any methods or properties attached to 'Array.prototype' can be called by any array.  You can _overwrite_ the properties/methods of an object's ancestor by attaching a property/method of the same name directly to the child object.  

Pictures are helpful:
![](https://cdn-images-1.medium.com/max/1200/1*S9Bi34EoJeYcpxPnH1IycQ.jpeg)

The long story is a bit longer.  The rest of this lesson tells the long story.
[TOP](#table-of-contents)
___
___
## Prototypical Fundamentals
When you hear that everything in JS is an object, this is literally true.  If you follow the _prototype chain_ of any native JS type (number, object, funciton, array, ...) you will find that it's oldest ancestor is 'Object'. Object with a Capital "O".  This isn't all theoretical, you can see it for yourself.  Complete these mini-exercises in ChromDev for a preview of coming attractions:
1. An Empty Object:
    1. Create an empty object called 'obj'.
    2. Type 'obj.' in the console, what options appear for autocomplete?
    3. Enter 'obj' in the console, see that arrow to the left of it?  click that. What do you see?
    4. Click on the arrow to the left of '\_\_proto\_\_: Object'.  What do you see?
    5. Enter 'obj.\_\_proto\_\_' in the console.  How does it compare to what you saw in the stpes above?
    6. Enter 'obj.\_\_proto\_\_.\_\_proto\_\_' in the console.
2. An Empty Array:
    1. Create an empty array called 'arr'.
    2. Type 'arr.' in the console, what options appear for autocomplete?
    3. Enter 'arr' in the console, see that arrow to the left of it?  click that. What do you see?
    4. Click on the arrow to the left of '\_\_proto\_\_: Array'.  What do you see?
    5. Click on the arrow to the left of '\_\_proto\_\_: Object'.  What do you see?
    6. Enter 'arr.\_\_proto\_\_' in the console.  How does it compare to what you saw in the stpes above?
    7. Enter 'arr.\_\_proto\_\_.\_\_proto\_\_' in the console.  How does it compare to what you saw in the stpes above?
    8. Enter 'arr.\_\_proto\_\_.\_\_proto\_\_.\_\_proto\_\_' in the console. 
3. An Empty Function:
    1. Create an empty function called 'fun'.
    2. Type 'fun.' in the console, what options appear for autocomplete?
    3. Enter 'fun' in the console, see that arrow to the left of it?  click that. What do you see?
    4. Enter 'fun.\_\_proto\_\_' in the console.  How does it compare to what you saw in the stpes above?
    5. Enter 'fun.\_\_proto\_\_.\_\_proto\_\_' in the console.  How does it compare to what you saw in the stpes above?
    6. Enter 'arr.\_\_proto\_\_.\_\_proto\_\_.\_\_proto\_\_' in the console.
    
Carry on to learn what all this means.    The rest of this chapter will cover the basics of inheritance in [Proto Lookup Chain](#proto-lookup-chain), present some tools for studying inheritance in the wild with [Useful Methods](#useful-methods), and finally provide some [Recommended Practices](#recommended-practices);
    
[TOP](#table-of-contents)
___
### Proto Lookup Chain
What you saw in the exercises above is the _prototype lookup chain_ for 3 primitive types in JS.  When you try to access a method or property that doesn't exist on an object, JS will travel all the way up the lookup chain in search of that keyword before throwing an error.  Ancestors in the lookup chain can be free-standing objects or properties on another object.

Examples are better than words, read em or run em. These examples use a property, what happens if you use a method instead?:
* Adding a property to an object:    
    ```javascript
    var ancestor_obj = {}; // lookup chain: ancestor_obj -> Object -> null
    ancestor_obj.prop; // undefined, nothing in this object's lookup chain has a '.prop'
    ancestor_obj.prop = 'prop';
    ancestor_obj.prop; // 'prop' 
    ```
* Setting and using object's lookup chain:
    ```javascript
    var child_obj = {};// lookup chain: child_obj -> Object.prototype -> null
    child_obj.prop; // undefined, nothing in this object's lookup chain has a '.prop'
    child_obj.__proto__ = ancestor_obj; // This syntax is great for learning, but slow for production.  We will cover better ways of doing this later on in this markdwon.
    child_obj.prop; // 'prop'.  
    child_obj; // lookup chain: child_obj -> ancestor_obj -> Objec.prototypet -> null 
    ```
* Overwriting an ancestor's property:
    ```javascript
    child_obj.prop; // 'prop'
    child_obj.prop = 'child prop';
    child_obj.prop; // 'child prop'
    ```

Everything in JS has a '.\_\_proto\_\_' property, this property determines the next stop in it's _lookup chain_.  The next stop also has a '.\_\_proto\_\_', and so on until you reach a 'null'.
[TOP](#table-of-contents)
___
### Useful Native Methods
In the examples above you saw how objects can have access to properties that aren't their own.  JS has a couple native methods to say whether a method is attached to an object, or accessible by the lookup chain.  You'll rarely ever have to use them in production, but they are great tools for studying and learning JS inheritance.

* [.getOwnPropertyNames()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames):
    ```javascript
    var ancestor_obj = {property: 'prop'};
    ancestor_obj.property; // 'prop'
    Object.getOwnPropertyNames(ancestor_obj); // ['property']
    var child_obj = {__proto__: ancestor_obj};
    child_obj.property; // 'prop'
    Object.getOwnPropertyNames(child_obj); // []
    ```
* [.hasOwnProperty()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty):
    ```javascript
    ancestor_obj.hasOwnProperty('property'); // true
    child_obj.hasOwnProperty('property'); // false
    ```
* Ask JS - there is a native method for determining child/ancestor relationships:
    ```javascript
    ancestor_obj.isPrototypeOf(child_obj); // true
    child_obj.isPrototypeOf(ancestor_obj); // false
    Object.prototype.isPrototypeOf(child_obj); // true
    Object.prototype.isPrototypeOf(ancestor_obj); // true
    ```
    
There are more similar methods, but these two will be the most useful for learning inheritance.  You may find them useful when you study the factory design patterns in the next chapter.

[TOP](#table-of-contents)
___
### Recommended Practices

[TOP](#table-of-contents)
___
___
## Using Inheritance Fundamentals
[TOP](#table-of-contents)
___
### Factories
[TOP](#table-of-contents)
___
### Factories and Closures
[TOP](#table-of-contents)
___
### Recommended Design Patterns
[TOP](#table-of-contents)
___
___
## Other Ways to Inherit
[TOP](#table-of-contents)
___
### Constructor Functions
important for reading mozilla documentation
[TOP](#table-of-contents)
___
### Classes with Constructor Functions 
[TOP](#table-of-contents)
___
### ES6 Classes 

ES6 introduced a lovely thing called 'classes'.  
If you've never programmed before, they will make your life easy as you begin to learn interitance and OOP modeling in JS.  
If you've already learned how prototypes work in JS you may or may not want to use them, but you'll appreciate the abstraction they provide.  
If you come from a language with true classical inheritance, don't start here.  First learn pure prototypical inheritance then learn how classes work in JS. The name is very misleading, they work nothing like true classes.

But easier isn't better.  We recommend classes only as a last resort.

RESOURCES:
* [Our progressive examples](https://github.com/jankeLearning/content-code/tree/master/Week%2003/classes)
* Two from Mozilla herself: [1](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes) [2](https://hacks.mozilla.org/2015/07/es6-in-depth-classes/)
* [very good examples from google](https://github.com/googlechrome/samples/tree/gh-pages/classes-es6)
* [advanced introduction](https://scotch.io/tutorials/better-javascript-with-es6-pt-ii-a-deep-dive-into-classes)
* [friendly introduction](https://ilikekillnerds.com/2015/02/a-guide-to-es6-classes/)
* [fancy things to do with classes](https://www.sitepoint.com/object-oriented-javascript-deep-dive-es6-classes/)


[TOP](#table-of-contents)
___
___
# Op Eds
[TOP](#table-of-contents)
___






# OOP 2 - Prototypical Inheritance

* [intro]()
* [recommended practices]() // which of the below to use
* [__proto__]()
* [__proto__ and prototype]()
* [the new: factories]()
* [the new: .create, .assign]()
* [recommeded design patterns]()
* [the old: constructors and 'new']()
* [the old: instanceof and constructor]()
* [ES6 classes]()

____________
Using JS for object oriented programming is cheating yourself.  JS is like the clay of life, it can be molded into anything.  But many things are a betrayal to it's true nature.  The beauty of the language lies it's functional aspects and its lack of classical inheritance.  If you know what that means, ignore it.  If you don't, forget about it.

In JS objects are the players, not the game.   The game is Functional Programming (closure, pure functions), the players are objects. If you have experience in most other programming languages this will take adjustment.  

JS is to classical programming as legos are to play-mobile.

The freedom can be overwhelimg.  It is easy to fall into common Classical design patterns, bad in the long run.  

This lesson will teach you the fundamentals of O-O inheritance in JS and provide you with 2 simple design patterns you can use.

great if you know something about programming already
	https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3

The seminal “Design Patterns” book by the Gang of Four is built around two foundational principles:
“Program to an interface, not an implementation,” and “favor object composition over class inheritance.”


https://medium.com/javascript-scene/javascript-factory-functions-vs-constructor-functions-vs-classes-2f22ceddf33e

midway down.  retailor objects and this lesson to use factories? be more js-specific?
	+ correct
	+ not see so many conflictings
	- more complicated (?)
	- will see classes everywhere
	- this opens slippery slopes
do classes but say what this article does
say this 'class' thing is one of MANY design patterns in js.  it's a good one to start with because it is easier to wrap your head around at first.  but as your understaniding of js grows, you can make cooler things

object.create, object.assign

https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a
	let animal = {
	  animalType: 'animal',
	 
	  describe () {
	    return `An ${this.animalType} with ${this.furColor} fur, 
	      ${this.legs} legs, and a ${this.tail} tail.`;
	  }
	};
	 
	let mouseFactory = function mouseFactory () {
	  return Object.assign(Object.create(animal), {
	    animalType: 'mouse',
	    furColor: 'brown',
	    legs: 4,
	    tail: 'long, skinny'
	  });
	};

	let mickey = mouseFactory();

	closures for data privacy


use factories not constructors.  ignore Classes
	close over values in returned objects


change data-structures problems from classes
	or leave it? 
	change it

patterns
	http://radar.oreilly.com/2014/03/javascript-without-the-this.html
	http://davidshariff.com/blog/javascript-inheritance-patterns/ 
		- function from crockford (each no centralized methods)
		- prototypal - best to teach?


___________________



class exercise:  convert .protos to classes

NO CLASSES.  IN 'OBJECTS' SAY NEVER TO USE CONSTRUCTORS.  WHEN READING MODULES SAY HOW THEY COULD ALL BE DONE WITHOUT INHERITANCE.



Other good alternatives include making better use of JavaScript modules as an alternative to inheritance (I recommend npm and ES6 modules with Browserify or WebPack), or simply cloning objects by copying properties from a source object to a new object (e.g. `Object.assign()`, `$.extend()`, `_.extend()`, etc…).




# OOP 2 - Classes and Inheritance
In the last installment you saw how to build programs from units of code called objects.  In the code-series 'Objects' you saw functions that produce objects.  This lesson you will see the next conceptual step (Inheritance) and the JS language feature for implementing it (Classes).
___
### Why Not Literals ?
Object literals are great for representing single objects, but the fail to capture the relationships between single objects.

An intuitive analogy is the tree of life:
* All mammals have hair and warm blood.
* Some mammals have wings and others don't, but they all still have hair.
* Mammals and reptiles all have a spine, but don't share warm blood.
* No two animals have an identical genome.
* ...

There is a hierarchy of traits in the animal kingdom.  Some traits are unique to single animals, some traits are unique to a species, some to a genus, ... until you arrive at a few traits common to ALL animals.

With object literals there is no efficient way to model this, you'd have to go object-by-object and make sure that the jelly fish has what it needs, the bat has what it needs, the lizard, ...  
Wouldn't it be nice if there was a way to simply say 'this object is a lizard' and automatically give it all lizard properties? And if we wanted to change shared properties of lizards without having to find ALL lizards and change them ALL one at a time?

There is with classes and inheritance.
___
### Why Classes and Inheritance ?
* _Dynamic Control_: Modify the behavior of your entire program from a single location (the Class definition).
* _Code Reuse_: Make endless objects without needing to write endless objects by hand.
* _Effective Modeling_: Create large and accurate models of the real world in your program by mimicking real-world classifications (ie. novels and thesauri are both books).

Understanding inheritance allows you to achieve more with less code. With Class syntax it's not only more with less, it's completely new possiblities.  
___
  
instances and classes  
  
what goes in class, what goes in instance?

* [outstanding video](https://www.youtube.com/watch?v=SS-9y0H3Si8)

